/* tslint:disable */
/* eslint-disable */

// ######################################## THIS FILE WAS GENERATED BY MONGOOSE-TSGEN ######################################## //

// NOTE: ANY CHANGES MADE WILL BE OVERWRITTEN ON SUBSEQUENT EXECUTIONS OF MONGOOSE-TSGEN.

import mongoose from 'mongoose';
import {
    ICharity,
    ICharityDocument,
} from '../../../charity/data-access/interfaces/charity.interface';

/**
 * Custom Types
 */
export type GetAllCasesQueryParams = {
    page?: number;
    limit?: number;
    offset?: number;
    sort?: string;
    mainType?: string;
    subType?: string;
    nestedSubType?: string;
};
export type FilterQueryParams = Pick<
    GetAllCasesQueryParams,
    'mainType' | 'subType' | 'nestedSubType'
>;
export type FilterObj = FilterQueryParams & { charity: string };
export type SortObj = { [key: string]: number };
export type PaginationObj = { page: number; limit: number };

/**
 * Lean version of CaseLocationDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `CaseDocument.toObject()`.
 * ```
 * const casesObject = cases.toObject();
 * ```
 */
export type ICaseLocation = {
    governorate:
        | 'Alexandria'
        | 'Assiut'
        | 'Aswan'
        | 'Beheira'
        | 'Bani Suef'
        | 'Cairo'
        | 'Daqahliya'
        | 'Damietta'
        | 'Fayyoum'
        | 'Gharbiya'
        | 'Giza'
        | 'Helwan'
        | 'Ismailia'
        | 'Kafr El Sheikh'
        | 'Luxor'
        | 'Marsa Matrouh'
        | 'Minya'
        | 'Monofiya'
        | 'New Valley'
        | 'North Sinai'
        | 'Port Said'
        | 'Qalioubiya'
        | 'Qena'
        | 'Red Sea'
        | 'Sharqiya'
        | 'Sohag'
        | 'South Sinai'
        | 'Suez'
        | 'Tanta';
    city?: string;
};

/**
 * Lean version of CaseDocument
 *
 * This has all Mongoose getters & functions removed. This type will be returned from `CaseDocument.toObject()`. To avoid conflicts with model names, use the type alias `CaseObject`.
 * ```
 * const casesObject = cases.toObject();
 * ```
 */
export type ICase = {
    charity: ICharity['_id'] | ICharity;
    title: string;
    description: string;
    mainType:
        | 'Sadaqa'
        | 'Zakah'
        | 'BloodDonation'
        | 'kafarat'
        | 'Adahi'
        | 'Campains'
        | 'UsedProperties';
    coverImage: string;
    location: ICaseLocation[];
    subType:
        | 'Aqeeqa'
        | 'BloodDonation'
        | 'Campains'
        | 'Yameen'
        | 'Fediat Siam'
        | 'Foqaraa'
        | 'Masakeen'
        | 'Gharemat'
        | 'Soqia Maa'
        | 'Health'
        | 'General Support'
        | 'Adahy'
        | 'usedBefore';
    nestedSubType?:
        | 'Wasla'
        | 'Hafr Beer'
        | 'Burns'
        | 'Operations & AssistiveDevices'
        | 'Mini Projects'
        | 'General Support';
    gender?: 'male' | 'female' | 'none';
    finished?: boolean;
    upVotes?: number;
    views?: number;
    dateFinished?: Date | number;
    donationNumbers?: number;
    helpedNumbers: number;
    freezed?: boolean;
    targetDonationAmount: number;
    currentDonationAmount?: number;
    _id: mongoose.Types.ObjectId;
    createdAt?: Date;
    updatedAt?: Date;
};


/**
 * Mongoose Query type
 *
 * This type is returned from query functions. For most use cases, you should not need to use this type explicitly.
 */
export type CaseQuery = mongoose.Query<any, ICaseDocument, CaseQueries> &
    CaseQueries;

/**
 * Mongoose Query helper types
 *
 * This type represents `CaseSchema.query`. For most use cases, you should not need to use this type explicitly.
 */
export type CaseQueries = {};

export type CaseMethods = {};

export type CaseStatics = {};

/**
 * Mongoose Model type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Case = mongoose.model<CaseDocument, CaseModel>("Case", CaseSchema);
 * ```
 */
export type ICaseModel = mongoose.Model<ICaseDocument, CaseQueries> & CaseStatics;

/**
 * Mongoose Schema type
 *
 * Assign this type to new Case schema instances:
 * ```
 * const CaseSchema: CaseSchema = new mongoose.Schema({ ... })
 * ```
 */
export type ICaseSchema = mongoose.Schema<
    ICaseDocument,
    ICaseModel,
    CaseMethods,
    CaseQueries
>;

/**
 * Mongoose Subdocument type
 *
 * Type of `CaseDocument["location"]` element.
 */
export type ICaseLocationDocument = mongoose.Types.Subdocument & {
    governorate:
        | 'Alexandria'
        | 'Assiut'
        | 'Aswan'
        | 'Beheira'
        | 'Bani Suef'
        | 'Cairo'
        | 'Daqahliya'
        | 'Damietta'
        | 'Fayyoum'
        | 'Gharbiya'
        | 'Giza'
        | 'Helwan'
        | 'Ismailia'
        | 'Kafr El Sheikh'
        | 'Luxor'
        | 'Marsa Matrouh'
        | 'Minya'
        | 'Monofiya'
        | 'New Valley'
        | 'North Sinai'
        | 'Port Said'
        | 'Qalioubiya'
        | 'Qena'
        | 'Red Sea'
        | 'Sharqiya'
        | 'Sohag'
        | 'South Sinai'
        | 'Suez'
        | 'Tanta';
    city?: string;
};

/**
 * Mongoose Document type
 *
 * Pass this type to the Mongoose Model constructor:
 * ```
 * const Case = mongoose.model<CaseDocument, CaseModel>("Case", CaseSchema);
 * ```
 */
export type ICaseDocument = mongoose.Document<
    mongoose.Types.ObjectId,
    CaseQueries
> &
    CaseMethods & {
        charity: ICharityDocument['_id'] | ICharityDocument;
        title: string;
        description: string;
        mainType:
            | 'Sadaqa'
            | 'Zakah'
            | 'BloodDonation'
            | 'kafarat'
            | 'Adahi'
            | 'Campains'
            | 'UsedProperties';
        coverImage: string;
        location: mongoose.Types.Array<ICaseLocationDocument>;
        subType:
            | 'Aqeeqa'
            | 'BloodDonation'
            | 'Campains'
            | 'Yameen'
            | 'Fediat Siam'
            | 'Foqaraa'
            | 'Masakeen'
            | 'Gharemat'
            | 'Soqia Maa'
            | 'Health'
            | 'General Support'
            | 'Adahy'
            | 'usedBefore';
        nestedSubType?:
            | 'Wasla'
            | 'Hafr Beer'
            | 'Burns'
            | 'Operations & AssistiveDevices'
            | 'Mini Projects'
            | 'General Support';
        gender?: 'male' | 'female' | 'none';
        finished?: boolean;
        upVotes?: number;
        views?: number;
        dateFinished?: Date | number;
        donationNumbers?: number;
        helpedNumbers: number;
        freezed?: boolean;
        targetDonationAmount: number;
        currentDonationAmount?: number;
        _id: mongoose.Types.ObjectId;
        createdAt: Date;
        updatedAt: Date;
    };

/**
 * Check if a property on a document is populated:
 * ```
 * import { IsPopulated } from "../interfaces/mongoose.gen.ts"
 *
 * if (IsPopulated<UserDocument["bestFriend"]>) { ... }
 * ```
 */
export function IsPopulated<T>(doc: T | mongoose.Types.ObjectId): doc is T {
    return doc instanceof mongoose.Document;
}

/**
 * Helper type used by `PopulatedDocument`. Returns the parent property of a string
 * representing a nested property (i.e. `friend.user` -> `friend`)
 */
type ParentProperty<T> = T extends `${infer P}.${string}` ? P : never;

/**
 * Helper type used by `PopulatedDocument`. Returns the child property of a string
 * representing a nested property (i.e. `friend.user` -> `user`).
 */
type ChildProperty<T> = T extends `${string}.${infer C}` ? C : never;

/**
 * Helper type used by `PopulatedDocument`. Removes the `ObjectId` from the general union type generated
 * for ref documents (i.e. `mongoose.Types.ObjectId | UserDocument` -> `UserDocument`)
 */
type PopulatedProperty<Root, T extends keyof Root> = Omit<Root, T> & {
    [ref in T]: Root[T] extends mongoose.Types.Array<infer U>
        ? mongoose.Types.Array<Exclude<U, mongoose.Types.ObjectId>>
        : Exclude<Root[T], mongoose.Types.ObjectId>;
};

/**
 * Populate properties on a document type:
 * ```
 * import { PopulatedDocument } from "../interfaces/mongoose.gen.ts"
 *
 * function example(user: PopulatedDocument<UserDocument, "bestFriend">) {
 *   console.log(user.bestFriend._id) // typescript knows this is populated
 * }
 * ```
 */
export type PopulatedDocument<DocType, T> = T extends keyof DocType
    ? PopulatedProperty<DocType, T>
    : ParentProperty<T> extends keyof DocType
    ? Omit<DocType, ParentProperty<T>> & {
          [ref in ParentProperty<T>]: DocType[ParentProperty<T>] extends mongoose.Types.Array<
              infer U
          >
              ? mongoose.Types.Array<
                    ChildProperty<T> extends keyof U
                        ? PopulatedProperty<U, ChildProperty<T>>
                        : PopulatedDocument<U, ChildProperty<T>>
                >
              : ChildProperty<T> extends keyof DocType[ParentProperty<T>]
              ? PopulatedProperty<DocType[ParentProperty<T>], ChildProperty<T>>
              : PopulatedDocument<DocType[ParentProperty<T>], ChildProperty<T>>;
      }
    : DocType;

/**
 * Helper types used by the populate overloads
 */
type Unarray<T> = T extends Array<infer U> ? U : T;
type Modify<T, R> = Omit<T, keyof R> & R;

/**
 * Augment mongoose with Query.populate overloads
 */
declare module 'mongoose' {
    interface Query<ResultType, DocType, THelpers = {}> {
        populate<T extends string>(
            path: T,
            select?: string | any,
            model?: string | Model<any, THelpers>,
            match?: any
        ): Query<
            ResultType extends Array<DocType>
                ? Array<PopulatedDocument<Unarray<ResultType>, T>>
                : ResultType extends DocType
                ? PopulatedDocument<Unarray<ResultType>, T>
                : ResultType,
            DocType,
            THelpers
        > &
            THelpers;

        populate<T extends string>(
            options:
                | Modify<PopulateOptions, { path: T }>
                | Array<PopulateOptions>
        ): Query<
            ResultType extends Array<DocType>
                ? Array<PopulatedDocument<Unarray<ResultType>, T>>
                : ResultType extends DocType
                ? PopulatedDocument<Unarray<ResultType>, T>
                : ResultType,
            DocType,
            THelpers
        > &
            THelpers;
    }
}
